[[section-design-decisions]]

== Entwurfsentscheidungen


=== Keine `null`-Werte

Mit http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html[Optional] aus Java 8 besteht keine Notwendigkeit mehr, `null` als Argument oder Rückgabewert zulassen.
Dementsprechend wird bei Rückgabewerte, die optional sind, auch http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html[Optional] als Datentyp zurückgegeben.
`null` als Rückgabewert wird nicht verwendet.

Auch bei Parametern ist `null` kein zulässiges Argument, sondern wird als Fehler betrachtet und mit einer ValidationException bestraft.
Optionale Parameter können beim Aufruf einfach weggelassen werden


=== Kein Logging / Minimale Abhängigkeiten

Um nicht von einem bestimmten Log-Framework abhängig zu sein, wurde auf Logging weitgehend verzichtet.
Das bedeutet, dass in einem Falle eines Fehlers oder fehlerhaften Aufrufs eine hilfreiche Exception ausgelöst wird.
Diese Exception stellt alle Informationen zur Verfügung, um die Ursache des Fehlers zu finden.
Eine Ausnahme hiervon ist die FachwertFactory-Klasse, da hier Exceptions behandelt werden.
Dazu wird aber das Logging-Framework des JDKs im Log-Level FINE verwendet.

Um sich nicht weitere unerwünschte Abhängigkeiten bei der Verwendung von jFachwert einzufangen, werden die Abhängigkeiten zu anderen Bibiotheken auf ein Minimum reduziert.
Die einzigen Abhängigkeiten, die in Kauf genommen werden, sind:

* commons-lang3: diese Bibliothek ist bereits als Abhängigkeit vieler anderer Bibliotheken vorhanden
* validation-api: Basis-Bibliothek für Validierung
* money-api (JSR 354): diese API ist Bestandteil ab Java 9
* JavaMoney.org: diese Bibliothek kam mit 0.8 für die Unterstützung des Geldbetrags herein, da sonst `Monetary.getCurrency("EUR")` nicht funktioniert.


=== Ableitung möglich

Um für Fachklassen auch eigene Logik hinterlegen zu können, können die Klassen abgeleitet werden.
Deswegen sind die Klassen nicht `final` und besitzen keine statischen Methoden, die `public` sind.


=== Konstruktor mit Validierung

Jede Klasse besitzt einen Konstruktor, der als letztes Argument einen Validator (z.B. in Form eines Pruefzifferverfahrens) hat.
Damit ist sichergestellt, dass

* nur gültige Fachwerte erzeugt werden können,
* der Validator von der abgeleiteten Klasse ver- oder entschärft werden kann (je nach Anforderung).



=== of-Methode

Ursprünglich wurde auf eine statische `of`-Methode, wie sie seit Java 8 bei vielen Klassen aus dem JDK üblich ist (Beispiel: `LocalDate.of(jahr, monat, tag)`), bis v0.6 verzichtet,
weil statische Methoden von abgeleiteten Klassen nicht überschrieben werden können.
Mit der Einführung des math-Package in v0.6 wurde of bei einigen Klassen eine statische `of`-Methode aus folgenden Gründen eingeführt:
                   
* Die Anzahl (und Speicherverbrauch) lässt sich reduzieren, indem oft gebrauchte Werte "vorgehalten" werden.
* erhöhte Lesbarkeit

Dies lohnt sich vor allem für Objekte, die immer den gleichen Werte oder nur einige Werte haben (z.B. Rechnungsmonat).
Dies kann bei sehr vielen Objekten einen spürbaren Rückgang des Speicherverbraucs bedeuten.
Bei vielen unterschiedlichen Objekten (z.B. IBAN) sollte man dagegen eher auf den Konstruktor verwenden, weil intern ein Cache für die die Ablage bereits erzeugter Objekte verwendet wird.
Der interne Verwaltungs-Overhead ist umso größer, je mehr unterschiedliche Objekte erzeugt werden.



=== Gleichheit

Die equals- und hashCode-Methode wurden jeweils überschrieben.
Zwei Fachwerte sind gleich, wenn sie jeweils die gleichen Werte besitzen.


=== toString

Jeder Fachwert hat eine aussagekräftige `toString`-Implementierung.
Meist ist dies der Wert selbst.
